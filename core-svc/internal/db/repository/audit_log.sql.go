// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audit_log.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) FROM audit_log
`

func (q *Queries) CountAuditLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogs)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsByActor = `-- name: CountAuditLogsByActor :one
SELECT COUNT(*) FROM audit_log WHERE actor_user_id = $1
`

func (q *Queries) CountAuditLogsByActor(ctx context.Context, actorUserID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsByActor, actorUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAuditLogsBySubject = `-- name: CountAuditLogsBySubject :one
SELECT COUNT(*) FROM audit_log WHERE subject_type = $1 AND subject_id = $2
`

type CountAuditLogsBySubjectParams struct {
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
}

func (q *Queries) CountAuditLogsBySubject(ctx context.Context, arg CountAuditLogsBySubjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogsBySubject, arg.SubjectType, arg.SubjectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_log (actor_user_id, action, subject_type, subject_id, meta)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, actor_user_id, action, subject_type, subject_id, meta, created_at
`

type CreateAuditLogParams struct {
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.ActorUserID,
		arg.Action,
		arg.SubjectType,
		arg.SubjectID,
		arg.Meta,
	)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.Action,
		&i.SubjectType,
		&i.SubjectID,
		&i.Meta,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT
    al.id,
    al.actor_user_id,
    al.action,
    al.subject_type,
    al.subject_id,
    al.meta,
    al.created_at,
    u.name as actor_name,
    u.email as actor_email
FROM audit_log al
LEFT JOIN app_user u ON al.actor_user_id = u.id
WHERE al.id = $1
`

type GetAuditLogByIDRow struct {
	ID          uuid.UUID   `json:"id"`
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
	CreatedAt   time.Time   `json:"created_at"`
	ActorName   pgtype.Text `json:"actor_name"`
	ActorEmail  pgtype.Text `json:"actor_email"`
}

func (q *Queries) GetAuditLogByID(ctx context.Context, id uuid.UUID) (GetAuditLogByIDRow, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i GetAuditLogByIDRow
	err := row.Scan(
		&i.ID,
		&i.ActorUserID,
		&i.Action,
		&i.SubjectType,
		&i.SubjectID,
		&i.Meta,
		&i.CreatedAt,
		&i.ActorName,
		&i.ActorEmail,
	)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT
    al.id,
    al.actor_user_id,
    al.action,
    al.subject_type,
    al.subject_id,
    al.meta,
    al.created_at,
    u.name as actor_name,
    u.email as actor_email
FROM audit_log al
LEFT JOIN app_user u ON al.actor_user_id = u.id
ORDER BY al.created_at DESC
LIMIT $1 OFFSET $2
`

type ListAuditLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAuditLogsRow struct {
	ID          uuid.UUID   `json:"id"`
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
	CreatedAt   time.Time   `json:"created_at"`
	ActorName   pgtype.Text `json:"actor_name"`
	ActorEmail  pgtype.Text `json:"actor_email"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]ListAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, listAuditLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsRow
	for rows.Next() {
		var i ListAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.Action,
			&i.SubjectType,
			&i.SubjectID,
			&i.Meta,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByAction = `-- name: ListAuditLogsByAction :many
SELECT
    al.id,
    al.actor_user_id,
    al.action,
    al.subject_type,
    al.subject_id,
    al.meta,
    al.created_at,
    u.name as actor_name,
    u.email as actor_email
FROM audit_log al
LEFT JOIN app_user u ON al.actor_user_id = u.id
WHERE al.action = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByActionParams struct {
	Action string `json:"action"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListAuditLogsByActionRow struct {
	ID          uuid.UUID   `json:"id"`
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
	CreatedAt   time.Time   `json:"created_at"`
	ActorName   pgtype.Text `json:"actor_name"`
	ActorEmail  pgtype.Text `json:"actor_email"`
}

func (q *Queries) ListAuditLogsByAction(ctx context.Context, arg ListAuditLogsByActionParams) ([]ListAuditLogsByActionRow, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsByActionRow
	for rows.Next() {
		var i ListAuditLogsByActionRow
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.Action,
			&i.SubjectType,
			&i.SubjectID,
			&i.Meta,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsByActor = `-- name: ListAuditLogsByActor :many
SELECT
    al.id,
    al.actor_user_id,
    al.action,
    al.subject_type,
    al.subject_id,
    al.meta,
    al.created_at,
    u.name as actor_name,
    u.email as actor_email
FROM audit_log al
LEFT JOIN app_user u ON al.actor_user_id = u.id
WHERE al.actor_user_id = $1
ORDER BY al.created_at DESC
LIMIT $2 OFFSET $3
`

type ListAuditLogsByActorParams struct {
	ActorUserID uuid.UUID `json:"actor_user_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListAuditLogsByActorRow struct {
	ID          uuid.UUID   `json:"id"`
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
	CreatedAt   time.Time   `json:"created_at"`
	ActorName   pgtype.Text `json:"actor_name"`
	ActorEmail  pgtype.Text `json:"actor_email"`
}

func (q *Queries) ListAuditLogsByActor(ctx context.Context, arg ListAuditLogsByActorParams) ([]ListAuditLogsByActorRow, error) {
	rows, err := q.db.Query(ctx, listAuditLogsByActor, arg.ActorUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsByActorRow
	for rows.Next() {
		var i ListAuditLogsByActorRow
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.Action,
			&i.SubjectType,
			&i.SubjectID,
			&i.Meta,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditLogsBySubject = `-- name: ListAuditLogsBySubject :many
SELECT
    al.id,
    al.actor_user_id,
    al.action,
    al.subject_type,
    al.subject_id,
    al.meta,
    al.created_at,
    u.name as actor_name,
    u.email as actor_email
FROM audit_log al
LEFT JOIN app_user u ON al.actor_user_id = u.id
WHERE al.subject_type = $1 AND al.subject_id = $2
ORDER BY al.created_at DESC
LIMIT $3 OFFSET $4
`

type ListAuditLogsBySubjectParams struct {
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type ListAuditLogsBySubjectRow struct {
	ID          uuid.UUID   `json:"id"`
	ActorUserID uuid.UUID   `json:"actor_user_id"`
	Action      string      `json:"action"`
	SubjectType string      `json:"subject_type"`
	SubjectID   pgtype.UUID `json:"subject_id"`
	Meta        []byte      `json:"meta"`
	CreatedAt   time.Time   `json:"created_at"`
	ActorName   pgtype.Text `json:"actor_name"`
	ActorEmail  pgtype.Text `json:"actor_email"`
}

func (q *Queries) ListAuditLogsBySubject(ctx context.Context, arg ListAuditLogsBySubjectParams) ([]ListAuditLogsBySubjectRow, error) {
	rows, err := q.db.Query(ctx, listAuditLogsBySubject,
		arg.SubjectType,
		arg.SubjectID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAuditLogsBySubjectRow
	for rows.Next() {
		var i ListAuditLogsBySubjectRow
		if err := rows.Scan(
			&i.ID,
			&i.ActorUserID,
			&i.Action,
			&i.SubjectType,
			&i.SubjectID,
			&i.Meta,
			&i.CreatedAt,
			&i.ActorName,
			&i.ActorEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
