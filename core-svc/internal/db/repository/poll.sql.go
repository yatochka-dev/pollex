// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: poll.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPollWithOptions = `-- name: CreatePollWithOptions :one
WITH new_poll AS (
INSERT INTO poll (question, user_id)
VALUES ($1, $2)
    RETURNING id, question, user_id, created_at, closed
    ),
    ins_opts AS (
INSERT INTO poll_option (poll_id, label)
SELECT np.id, o::text
FROM new_poll np
    CROSS JOIN unnest($3::text[]) AS o
    )
SELECT p.id, p.question, p.user_id, p.created_at, p.closed,
       ARRAY(
           SELECT po.label
         FROM poll_option po
         WHERE po.poll_id = p.id
         ORDER BY po.id
       ) AS options
FROM new_poll p
`

type CreatePollWithOptionsParams struct {
	Question string    `json:"question"`
	UserID   uuid.UUID `json:"user_id"`
	Options  []string  `json:"options"`
}

type CreatePollWithOptionsRow struct {
	ID        uuid.UUID          `json:"id"`
	Question  string             `json:"question"`
	UserID    uuid.UUID          `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Closed    bool               `json:"closed"`
	Options   interface{}        `json:"options"`
}

func (q *Queries) CreatePollWithOptions(ctx context.Context, arg CreatePollWithOptionsParams) (CreatePollWithOptionsRow, error) {
	row := q.db.QueryRow(ctx, createPollWithOptions, arg.Question, arg.UserID, arg.Options)
	var i CreatePollWithOptionsRow
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.UserID,
		&i.CreatedAt,
		&i.Closed,
		&i.Options,
	)
	return i, err
}

const getPollByID = `-- name: GetPollByID :one
SELECT id, question, created_at, user_id, closed FROM poll
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPollByID(ctx context.Context, id uuid.UUID) (Poll, error) {
	row := q.db.QueryRow(ctx, getPollByID, id)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.CreatedAt,
		&i.UserID,
		&i.Closed,
	)
	return i, err
}

const getPollWithOptions = `-- name: GetPollWithOptions :one
SELECT p.id, p.question, p.created_at, p.user_id, p.closed,
       ARRAY(
           SELECT po.label
         FROM poll_option po
         WHERE po.poll_id = p.id
         ORDER BY po.id
       ) AS options
FROM poll p
WHERE p.id = $1
`

type GetPollWithOptionsRow struct {
	ID        uuid.UUID          `json:"id"`
	Question  string             `json:"question"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UserID    uuid.UUID          `json:"user_id"`
	Closed    bool               `json:"closed"`
	Options   interface{}        `json:"options"`
}

func (q *Queries) GetPollWithOptions(ctx context.Context, id uuid.UUID) (GetPollWithOptionsRow, error) {
	row := q.db.QueryRow(ctx, getPollWithOptions, id)
	var i GetPollWithOptionsRow
	err := row.Scan(
		&i.ID,
		&i.Question,
		&i.CreatedAt,
		&i.UserID,
		&i.Closed,
		&i.Options,
	)
	return i, err
}

const getPollsByUserID = `-- name: GetPollsByUserID :many
SELECT id, question, created_at, user_id, closed FROM poll
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetPollsByUserID(ctx context.Context, userID uuid.UUID) ([]Poll, error) {
	rows, err := q.db.Query(ctx, getPollsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Poll
	for rows.Next() {
		var i Poll
		if err := rows.Scan(
			&i.ID,
			&i.Question,
			&i.CreatedAt,
			&i.UserID,
			&i.Closed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOptionsByPollID = `-- name: ListOptionsByPollID :many
SELECT id, poll_id, label, created_at FROM poll_option WHERE poll_id = $1
`

func (q *Queries) ListOptionsByPollID(ctx context.Context, pollID uuid.UUID) ([]PollOption, error) {
	rows, err := q.db.Query(ctx, listOptionsByPollID, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PollOption
	for rows.Next() {
		var i PollOption
		if err := rows.Scan(
			&i.ID,
			&i.PollID,
			&i.Label,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
