// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: email_verify_tokens.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUnusedTokensByUserID = `-- name: CountUnusedTokensByUserID :one
SELECT COUNT(*)
FROM email_verify_tokens
WHERE user_id = $1
  AND used_at IS NULL
  AND expires_at > NOW()
`

func (q *Queries) CountUnusedTokensByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnusedTokensByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmailVerifyToken = `-- name: CreateEmailVerifyToken :one
INSERT INTO email_verify_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token_hash, expires_at, used_at, created_at
`

type CreateEmailVerifyTokenParams struct {
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) CreateEmailVerifyToken(ctx context.Context, arg CreateEmailVerifyTokenParams) (EmailVerifyToken, error) {
	row := q.db.QueryRow(ctx, createEmailVerifyToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i EmailVerifyToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteEmailVerifyTokensByUserID = `-- name: DeleteEmailVerifyTokensByUserID :exec
DELETE FROM email_verify_tokens
WHERE user_id = $1
`

func (q *Queries) DeleteEmailVerifyTokensByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEmailVerifyTokensByUserID, userID)
	return err
}

const deleteExpiredEmailVerifyTokens = `-- name: DeleteExpiredEmailVerifyTokens :exec
DELETE FROM email_verify_tokens
WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredEmailVerifyTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredEmailVerifyTokens)
	return err
}

const getEmailVerifyTokenByHash = `-- name: GetEmailVerifyTokenByHash :one
SELECT id, user_id, token_hash, expires_at, used_at, created_at
FROM email_verify_tokens
WHERE token_hash = $1
LIMIT 1
`

func (q *Queries) GetEmailVerifyTokenByHash(ctx context.Context, tokenHash string) (EmailVerifyToken, error) {
	row := q.db.QueryRow(ctx, getEmailVerifyTokenByHash, tokenHash)
	var i EmailVerifyToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUnusedEmailVerifyTokenByUserID = `-- name: GetUnusedEmailVerifyTokenByUserID :one
SELECT id, user_id, token_hash, expires_at, used_at, created_at
FROM email_verify_tokens
WHERE user_id = $1
  AND used_at IS NULL
  AND expires_at > NOW()
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetUnusedEmailVerifyTokenByUserID(ctx context.Context, userID uuid.UUID) (EmailVerifyToken, error) {
	row := q.db.QueryRow(ctx, getUnusedEmailVerifyTokenByUserID, userID)
	var i EmailVerifyToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const isEmailVerified = `-- name: IsEmailVerified :one
SELECT email_verified_at IS NOT NULL AS is_verified
FROM app_user
WHERE id = $1
`

func (q *Queries) IsEmailVerified(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, isEmailVerified, id)
	var is_verified interface{}
	err := row.Scan(&is_verified)
	return is_verified, err
}

const markEmailVerifyTokenUsed = `-- name: MarkEmailVerifyTokenUsed :one
UPDATE email_verify_tokens
SET used_at = NOW()
WHERE id = $1
RETURNING id, user_id, token_hash, expires_at, used_at, created_at
`

func (q *Queries) MarkEmailVerifyTokenUsed(ctx context.Context, id uuid.UUID) (EmailVerifyToken, error) {
	row := q.db.QueryRow(ctx, markEmailVerifyTokenUsed, id)
	var i EmailVerifyToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.UsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const setUserEmailVerified = `-- name: SetUserEmailVerified :one
UPDATE app_user
SET email_verified_at = NOW()
WHERE id = $1
RETURNING id, name, email, role, email_verified_at, created_at
`

type SetUserEmailVerifiedRow struct {
	ID              uuid.UUID          `json:"id"`
	Name            string             `json:"name"`
	Email           string             `json:"email"`
	Role            UserRole           `json:"role"`
	EmailVerifiedAt pgtype.Timestamptz `json:"email_verified_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) SetUserEmailVerified(ctx context.Context, id uuid.UUID) (SetUserEmailVerifiedRow, error) {
	row := q.db.QueryRow(ctx, setUserEmailVerified, id)
	var i SetUserEmailVerifiedRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Role,
		&i.EmailVerifiedAt,
		&i.CreatedAt,
	)
	return i, err
}
